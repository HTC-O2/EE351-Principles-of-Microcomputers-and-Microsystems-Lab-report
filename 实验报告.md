姓名：蓝靖淇 学号：12313517

# Lab1 Raspberry Pi系统安装与 SSH/VNC 服务

## 实验目的

1.掌握 SD 卡格式化及树莓派系统的多种安装方法，成功制作树莓派启动盘。

2.完成树莓派硬件接线与开机初始设置，确保设备正常运行。

3.启用 SSH 和 VNC 远程连接服务，实现电脑与树莓派的远程控制，熟悉不同远程连接工具的使用。

## 实验过程

### SD 卡格式化

1.将树莓派的 SD 卡插入读卡器，再连接至电脑，检查是否插好。

2.从群文件 “raspberry pi 安装” 中下载 SD Formatter 格式化工具并打开。

3.选择目标 SD 卡，勾选 “快速格式化”，关闭逻辑大小调整，点击 “格式化”。

4.为避免硬件原因导致的格式化问题，重复格式化操作 3-4 次。

![image1](实验报告_media/media/image1.png)

### 树莓派系统安装

使用 Raspberry Pi Imager 直接安装

1.从树莓派官网下载对应系统（Windows、macOS、Ubuntu 等）的 Raspberry Pi Imager 工具，按提示安装。

2.打开工具，依次选择设备（如 Raspberry Pi 4）、操作系统（Other 分类下的 Raspberry Pi OS Full 32-bit）和目标 SD 卡。

3.配置系统参数，设置主机名、用户名、密码，WIFI 国家选择 CN 并输入与电脑移动热点一致的 WIFI 名称和密码（语言设置可不填）。

4.点击 “下一步” 开始烧录，若烧录出错，检查 SD 卡插入情况后重复操作。

![image2](实验报告_media/media/image2.png)
![image3](实验报告_media/media/image3.png)

### 硬件接线与开机设置

1.将烧录好系统的 SD 卡插入树莓派卡槽，连接 5V3A Type-c 电源、HDMI 转 micro HDMI 数据线，以及鼠标和键盘（树莓派通过 USB 向屏幕供电，HDMI 传输显示数据）。

2.接通电源开机，进入初始设置界面，依次完成语言地区选择、密码修改（可不设置）等配置。

3.打开左上角命令行，准备后续服务配置。

![image4](实验报告_media/media/image4.png)
![image5](实验报告_media/media/image5.png)

### SSH 与 VNC 远程连接配置

#### 基础准备

1.点击左上角 “Preferences”-“Raspberry Pi Configuration”-“Interfaces”，将 SSH 和 VNC 均设置为 “Enable”，点击 “OK”。

2.连接指定 WIFI（如 SUSTech-wifi 或电脑移动热点），打开命令行输入 “ifconfig”，获取树莓派局域网 IP 地址（示例：10.17.106.219）。

![image6](实验报告_media/media/image6.png)
![image7](实验报告_media/media/image7.png)

#### SSH 远程连接

1.确保电脑与树莓派处于同一局域网，下载并打开 Mobaxterm 工具。

2.在 “Host Name” 框中输入树莓派 IP 地址，端口保持 22，点击 “Open”。

3.输入树莓派用户名（默认 pi）和密码（默认 raspberry 或自定义密码），完成连接。

![image8](实验报告_media/media/image8.png)

#### VNC 远程连接

1.下载并安装 VNC-Viewer 软件，确保电脑与树莓派处于同一局域网。

2.打开 VNC-Viewer，输入树莓派 IP 地址，回车后输入用户名和密码，点击 “OK” 即可远程访问树莓派桌面。

![image9](实验报告_media/media/image9.png)

## 实验结果

1.SD 卡格式化成功，无硬件相关故障，满足系统安装前提条件。

2.树莓派系统安装完成，开机后能正常进入初始设置界面，基础功能运行正常。

3.硬件接线正确，树莓派可通过 USB 正常供电，HDMI 数据线稳定传输显示画面。

4.SSH 服务启用成功，通过 Putty 等工具可远程登录树莓派终端并执行命令。

5.VNC 服务连接正常，实现树莓派桌面的远程可视化控制；xrdp 远程桌面连接备选方案同样可用。

6.所有远程连接均基于同一局域网实现，连接稳定，无频繁断开或验证失败问题。

# Lab2 学习知识准备与双色LED实验

## 实验目的

1.熟悉 Raspberry Pi 40 针接口的物理编号、wiringPi 编号和 BCM 编号体系，为后续电路接线和编程打基础。
2.能够在 Raspberry Pi 上安装并测试 wiringPi 库，掌握基本的命令行验证方法。
3.了解 RPi.GPIO 库的使用场景，学会在 Mu IDE 中编写、调试和运行 Python 代码。
4.完成 Geany IDE 的编译链配置，支持使用 wiringPi 进行 C/C++ 开发。
5.搭建双色 LED 控制电路，实现颜色切换与闪烁等基础实验效果。
6.掌握 MobaXterm、VNC Viewer 在 Raspberry Pi 与 PC 之间的文件传输操作，并配置 VNC 的文件权限。

## 实验过程

### Raspberry Pi IO 认识

1.查阅 40 针排针的官方引脚图，区分物理引脚号（Header）、wiringPi 引脚号和 BCM 引脚号。
2.确认实验 T 型扩展板默认使用 BCM 编号，示例：G27 对应 BCM27，GPIO13 对应 BCM13。
3.根据实验需要，提前规划双色 LED 与其他外设所占用的引脚，确保编号一致。

### wiringPi 安装与验证

1.使用 MobaXterm 或 VNC Viewer 将 `WiringPi.zip` 上传至 Raspberry Pi，本实验演示将压缩包解压到 `/temp` 目录。
2.进入解压目录，运行 `./build` 安装 wiringPi；若出现 `permission denied`，先执行 `sudo chmod 777 build` 再次运行。
3.安装完成后，通过 `gpio -v` 和 `gpio readall` 检查版本信息与引脚映射是否正确显示，确认库可用。

### RPi.GPIO 库与 Mu IDE

1.Raspbian 系统默认内置 RPi.GPIO，如需额外组件可执行 `sudo apt-get install python-dev` 补充头文件。
2.启动 Mu IDE，选择 Python 3 模式新建脚本，示例编写 “Hello World” 并使用 `Run` 测试。
3.利用 Mu 的 `Check` 与 `Debug` 功能，演练语法校验、单步执行、查看变量状态等调试流程，为后续 GPIO 控制打基础。

### Geany IDE 配置

1.从 Raspberry Pi 桌面菜单 `Programming` 启动 Geany，新建 `helloworld.c`。
2.在 `Build` → `Set Build Commands` 中，为 `Compile` 与 `Build` 追加 `-lwiringPi` 链接选项。
3.保存后依次点击 `Compile`、`Build`、`Execute`，验证 C 程序编译链可正常调用 wiringPi 库。

### 双色 LED 实验接线与编程

1.准备双色 LED（共阴或共阳）与限流电阻，参考原理图将红、绿两路分别连接到 Raspberry Pi 的 GPIO（示例使用 GPIO19、GPIO20），公共端接 GND。
2.在 T 型扩展板上操作时注意正负极方向，避免直接跨接导致短路，必要时调换 GPIO 引脚以匹配脚位。
3.使用 wiringPi（C 语言）或 RPi.GPIO（Python）编写控制程序，实现红灯亮、绿灯亮、两灯交替闪烁等效果。
4.运行程序观察双色 LED 的切换与闪烁，确认电路连接正确、代码逻辑满足实验目标。

### 文件互传：MobaXterm

1.启动 MobaXterm，新建 SSH Session 连接树莓派 IP，成功登录后可直接拖拽文件至 `Desktop` 等目录完成上传。
2.以 `WiringPi.zip` 为例，从本地拖动到远端桌面即可完成传输，便于整理实验所需资源。

### 文件互传：VNC Viewer

1.打开 VNC Viewer，连接树莓派桌面，点击工具栏 `File Transfer`。
2.在树莓派端若出现按钮灰色不可用，需要先调整 VNC 文件权限。
3.执行 `sudo raspi-config`→ `Advanced Options`→ `A6 Wayland`，选择 `w1 X11` 并确认，系统提示重启。
4.重启后，在 Raspberry Pi 桌面 `Preferences`→`Raspberry Pi Configuration`→`Interfaces` 中再次启用 VNC。
5.重新连接 VNC Viewer，即可通过 `Transfer files` 发送或接收文件，顺利完成与 PC 的双向传输。

### 程序代码

```python
import RPi.GPIO as GPIO  # 引入GPIO控制库
import time              # 引入时间延迟库

# 定义引脚（BCM编码）：红色LED接BCM 19，绿色LED接BCM 26
RED_LED = 19
GREEN_LED = 26

def setup():
    GPIO.setmode(GPIO.BCM)  # 设置引脚编码方式为BCM
    GPIO.setwarnings(False) # 关闭GPIO警告信息
    # 配置两个引脚为输出模式
    GPIO.setup(RED_LED, GPIO.OUT)
    GPIO.setup(GREEN_LED, GPIO.OUT)
    # 初始化引脚为低电平（LED熄灭）
    GPIO.output(RED_LED, GPIO.LOW)
    GPIO.output(GREEN_LED, GPIO.LOW)

def loop():
    while True:  # 无限循环，实现持续闪烁
        # 红色LED亮，绿色LED灭
        GPIO.output(RED_LED, GPIO.HIGH)
        GPIO.output(GREEN_LED, GPIO.LOW)
        time.sleep(0.5)  # 延迟0.5秒
        # 红色LED灭，绿色LED亮
        GPIO.output(RED_LED, GPIO.LOW)
        GPIO.output(GREEN_LED, GPIO.HIGH)
        time.sleep(0.5)  # 延迟0.5秒

def destroy():
    # 重置GPIO状态，避免引脚占用
    GPIO.output(RED_LED, GPIO.LOW)
    GPIO.output(GREEN_LED, GPIO.LOW)
    GPIO.cleanup()

if __name__ == "__main__":  # 程序入口
    try:
        setup()  # 初始化配置
        loop()   # 执行闪烁逻辑
    except KeyboardInterrupt:  # 捕获Ctrl+C中断
        destroy()  # 清理GPIO资源
```

## 实验结果

1.掌握了 Raspberry Pi GPIO 的物理、wiringPi、BCM 三套编号体系，能够在扩展板上正确定位目标引脚。
2.wiringPi 库成功安装并通过 `gpio` 命令验证，RPi.GPIO 与 Mu IDE 环境正常可用。
3.Geany IDE 完成 wiringPi 链接配置，实现了基于 C 的示例程序编译与运行。
4.双色 LED 硬件接线与控制程序调试成功，红绿灯可按设计交替闪烁。
5.MobaXterm、VNC Viewer 均能实现 PC 与 Raspberry Pi 间的文件互传，VNC 文件权限配置步骤清晰可复现。
6.整体实验流程顺利，为后续 GPIO 传感器与外设控制实验打下了软硬件基础。

![lab2-1](实验报告_media/media/lab2-1.png)
![lab2-2](实验报告_media/media/lab2-2.png)

# Lab3 轻触按键开关实验

## 实验目的

1.理解轻触按键模块的引脚结构与电气特性，明确按下与释放时的电平变化。
2.掌握在树莓派上配置 GPIO 输入模式并结合双色 LED 进行状态指示的方法。
3.通过编程实现按键多模式切换，熟悉消抖处理与状态机控制思路。
4.了解 RGB LED、倾斜开关、振动开关等替代器件的接线要点，为实验拓展做准备。

## 实验过程

### 模块介绍与布线准备

- 轻触按键模块的 S 引脚为信号输出，通过内部电阻与 VCC/GND 形成电平切换；按下输出低电平，松开输出高电平。
- 建议将树莓派 GPIO17 设为输入端，连接按键模块 SIG；模块的 VCC 与 GND 分别接树莓派 5V 与 GND。
- 双色 LED 可分配 GPIO18 控制红光、GPIO27 控制绿光，公共端接地；如使用红色 T 型扩展板，可直接插入 GPIO19、GPIO20 与 GND。
- 接线前确认彩虹排线方向，避免接口翻转；必要时使用杜邦线灵活调整与程序中引脚设置一致。

![lab3-实验过程](实验报告_media/media/lab3-实验过程.png)

### 实验原理

- 按键按下时树莓派读取到低电平，表示触发；松开时恢复高电平。
- 代码内根据输入电平驱动双色 LED，实现红灯/绿灯亮灭指示。
- 对按键输入进行消抖处理，可结合软延时或状态机判断保证触发稳定。

![lab3-实验原理](实验报告_media/media/lab3-实验原理.png)

### 程序实现要点

1. 初始化 GPIO，使用 BCM 编号配置输入与输出引脚，并为按键引脚启用内部上拉/下拉以稳定待机状态。
2. 编写循环或事件回调监测按键：
   - 第一次按下：红灯常亮；
   - 第二次按下：红灯闪烁；
   - 第三次按下：绿灯常亮；
   - 第四次按下：绿灯闪烁；
   - 后续按键继续在上述模式之间循环。
3. 设计简易状态机记录当前模式，并在按键被确认触发后切换状态。
4. 对每次状态切换进行日志打印或终端提示，便于调试验证。

## 实验结果

1. 按键按压与释放能够稳定改变 GPIO 读取电平，双色 LED 清晰反映状态。
2. 多模式切换逻辑运行正常，按键抖动通过软件去抖得到有效抑制。
3. 通过替代模块演示输入检测的多样性，为后续传感器扩展提供参考。
4. 实验代码与演示视频可用于作业提交，展示按键与 LED 联动效果。

![lab3-实验结果](实验报告_media/media/lab3-实验结果.png)

# Lab4 PCF8591 模数转换器实验

## 实验目的

1.了解 PCF8591 模数/数模转换芯片的接口特性与多通道配置方法。
2.掌握在树莓派上启用 I2C 总线、调用 `smbus` 库与外部 ADC 通信的流程。
3.实现基于 PCF8591 的电位器采样与 LED 亮度调节，完成 AD 与 DA 功能演示。
4.扩展开发呼吸灯与键盘输入控制等应用，强化模拟量处理与状态逻辑设计能力。
![lab4-实验原理-1](实验报告_media/media/lab4-实验原理-1.png)
![lab4-实验原理-2](实验报告_media/media/lab4-实验原理-2.png)
![lab4-实验原理-3](实验报告_media/media/lab4-实验原理-3.png)
## 实验过程

### 硬件准备与连接

- PCF8591 模块提供 4 路模拟输入与 1 路模拟输出，地址引脚 A0/A1/A2 决定 I2C 从地址（默认 0x48）。
- 将树莓派 SDA 接模块 SDA，SCL 接 SCL，5V 与 GND 分别供电；T 型转接板用于引出接口。
- 双色 LED 的红色引脚连接 PCF8591 `AOUT`，公共端接地；绿色引脚可悬空或用于扩展。
- 电位器输出接 PCF8591 `AIN0`，还可按需使用板载光敏与热敏电阻作为备用模拟输入。

### I2C 接口配置

1. 在树莓派桌面选择 `Preferences` → `Raspberry Pi Configuration`，于 `Interfaces` 页启用 I2C 后重启。
2. 若需核对地址，可在终端执行 `i2cdetect -y 1`，确认 0x48 设备在线。
3. Python 端安装 `smbus`（Raspbian 预装），通过 `smbus.SMBus(1)` 建立 `/dev/i2c-1` 通道实例。

### 程序代码

- PCF8591 控制字节高 4 位配置模拟输出与输入通道，低 4 位选择通道编号。
- 典型代码如下：

```python
import smbus
import time

ADDR = 0x48
CTRL = 0x40  # 使能 AOUT，单端读取 AIN0
bus = smbus.SMBus(1)

def read_channel(channel: int) -> int:
    ctrl = CTRL | (channel & 0x03)
    bus.write_byte(ADDR, ctrl)
    bus.read_byte(ADDR)  # 丢弃上次结果
    return bus.read_byte(ADDR)

def write_dac(value: int) -> None:
    value = max(0, min(255, value))
    bus.write_byte_data(ADDR, CTRL, value)

try:
    while True:
        raw = read_channel(0)
        voltage = raw * 3.3 / 255.0
        write_dac(raw)  # 将电位器读数映射回 AOUT
        print(f"ADC={raw:3d} Voltage={voltage:.2f} V")
        time.sleep(0.05)
except KeyboardInterrupt:
    pass
```

- 代码持续读取 `AIN0` 并实时回写 DAC，LED 亮度随电位器线性变化。

### AD 采样与读写联动

![lab4-实验过程](实验报告_media/media/lab4-实验过程.png)
![lab4-实验过程-2](实验报告_media/media/lab4-实验过程-2.png)

1. 先写入控制字节选择目标输入通道，再读取一个空字节丢弃旧值，随后读取有效数据。
2. 将 PCF8591 `AIN0` 接电位器，旋转电位器时记录返回的 0-255 范围采样值，并换算成电压。
3. 编写循环函数同时输出采样值与映射的 LED 亮度，完成 AD-DA 闭环控制。

## 实验结果

1. I2C 接口启用与设备寻址正常，`smbus` 成功与 PCF8591 完成数据传输。
2. PCF8591 数模输出可稳定调节 LED 亮度，键盘输入与电位器映射功能运行可靠。
3. 呼吸灯实验实现平滑亮度过渡，输出波形符合预期，说明 DA 控制逻辑正确。
4. 模块多通道采样为后续光敏/热敏传感器拓展奠定基础，实验数据可作为作业材料保存。

# Lab5 模拟温度传感器实验

## 实验目的

1.了解 NTC 热敏电阻的工作特性及其在温度测量中的应用方式。
2.掌握基于 PCF8591 的模拟信号采样流程，完成热敏电阻电压读取与阻值换算。
3.学习使用 Steinhart-Hart 方程从阻值推导摄氏温度，并评估参数选择带来的误差。
4.实现温度数据的实时打印或日志记录，构建后续环境监测的基础模块。
![lab5-实验原理-1](实验报告_media/media/lab5-实验原理-1.png)
![lab5-实验原理-2](实验报告_media/media/lab5-实验原理-2.png)

## 实验过程

### 硬件连接

- PCF8591 通过 I2C 与树莓派通信：`SDA ↔ SDA`、`SCL ↔ SCL`、`VCC ↔ 3.3V`、`GND ↔ GND`，地址默认为 `0x48`。
- 模拟温度传感器模块（NTC 热敏电阻 + 10kΩ 电阻）输出 `AO` 接入 PCF8591 `AIN0`，`VCC` 与 `GND` 分别接 3.3V 与地。
- 若传感器提供数字输出 `DO`，可接至树莓派 GPIO 监测阈值触发，但本实验主要使用模拟口。

![lab5-实验过程-1](实验报告_media/media/lab5-实验过程-1.png)

### 采样与温度换算原理

1. 通过 `read(0)` 获取 A/D 转换后的 0-255 数字量，对应输入电压范围 0-3.3V。
2. 将数字量换算为实际电压 `Vr = 3.3 * value / 255`。
3. 根据分压原理计算热敏电阻阻值 `Rt = 10000 * Vr / (3.3 - Vr)`，其中 10kΩ 为固定串联电阻。
4. 采用 Steinhart-Hart 方程求温度：

   - 标准参数：`T0 = 298.15K (25°C)`、`R0 = 10000Ω`、`B = 3950K`。
   - 公式推导：`1/T = 1/T0 + (1/B) * ln(Rt / R0)`，最终转换为摄氏度 `Tc = T - 273.15`。



### 程序代码

```python
import csv
import math
import smbus
import time
from collections import deque

ADDR = 0x48
CTRL = 0x40  # 单端 AIN0
T0 = 298.15
R0 = 10000.0
BETA = 3950.0

bus = smbus.SMBus(1)
history = deque(maxlen=5)

def read_adc() -> int:
    bus.write_byte(ADDR, CTRL)
    bus.read_byte(ADDR)
    return bus.read_byte(ADDR)

def read_temperature() -> float:
    value = read_adc()
    voltage = 3.3 * value / 255.0
    if voltage <= 0 or voltage >= 3.3:
        return float("nan")
    rt = R0 * voltage / (3.3 - voltage)
    inv_t = 1.0 / T0 + math.log(rt / R0) / BETA
    return (1.0 / inv_t) - 273.15

with open("temperature_log.csv", "a", newline="") as log:
    writer = csv.writer(log)
    writer.writerow(["timestamp", "celsius"])
    try:
        while True:
            temp = read_temperature()
            if math.isnan(temp):
                continue
            history.append(temp)
            avg = sum(history) / len(history)
            timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
            writer.writerow([timestamp, f"{avg:.2f}"])
            log.flush()
            print(f"Instant={temp:.2f}°C  Avg={avg:.2f}°C")
            time.sleep(1.0)
    except KeyboardInterrupt:
        pass
```

- 连续采集温度并写入 CSV，滑动平均缓冲减少抖动，终端同步显示实时与平滑温度。

### 实验注意事项

- 确保传感器与环境充分接触，避免手触导致瞬时升温影响数据。
- 若实际使用的热敏电阻参数不同，需要更新 `R0` 与 `BETA` 以提高精度。
- 可将多次采样结果写入 CSV，配合时间戳分析温度变化趋势。

## 实验结果

1. PCF8591 成功读取热敏电阻电压，换算后的温度在室温范围内稳定于 24-27°C。
2. 使用 Steinhart-Hart 方程可获得较为准确的摄氏温度，误差主要来源于参数假设与供电波动。
3. 通过滤波与缓存清理操作，采样抖动得到有效抑制，适合后续长时间监测。
4. 代码与采样日志满足作业提交要求，可进一步扩展为多点温度采集系统。

# Lab6 超声波传感器测距实验

## 实验目的

1.熟悉 HC-SR04 等超声波测距模块的工作原理与引脚定义。
2.掌握在树莓派上产生触发脉冲、捕获回波时间并换算距离的流程。
3.理解 5V 回波信号分压保护 GPIO 的必要性，培养硬件安全意识。
4.实现毫米级精度的距离测量，并评估测距误差与环境影响因素。

## 实验过程

### 硬件接线

- 模块引脚：`VCC` 接 5V、`Trig` 接 GPIO17、`Echo` 接 GPIO18、`GND` 接地。
- Echo 输出为 5V，需通过电阻分压（如 10kΩ/15kΩ）降至 3.3V 再连接树莓派 GPIO，防止芯片损坏。
- 使用 T 型转接板整理连线，确保地线共地，避免测距时信号漂移。

![lab6-实验过程-1](实验报告_media/media/lab6-实验过程-1.png)
![lab6-实验过程-2](实验报告_media/media/lab6-实验过程-2.png)

### 测距原理

1. GPIO17 输出至少 10µs 高电平触发模块发射 40kHz 超声波脉冲。
2. 模块在约 2ms 内发出 8 个周期的超声波，同时将 Echo 拉高。
3. 当接收到回波或超时 38ms，Echo 变回低电平。
4. 通过 `高电平持续时间 × 声速 / 2` 计算距离，声速按 340m/s 近似。

![lab6-实验原理-1](实验报告_media/media/lab6-实验原理-1.png)
![lab6-实验原理-2](实验报告_media/media/lab6-实验原理-2.png)

### 程序代码

```python
import time
import RPi.GPIO as GPIO

TRIG = 17
ECHO = 18
SPEED = 340.0  # m/s

GPIO.setmode(GPIO.BCM)
GPIO.setup(TRIG, GPIO.OUT)
GPIO.setup(ECHO, GPIO.IN)

def measure_distance(timeout: float = 0.03) -> float:
    GPIO.output(TRIG, False)
    time.sleep(0.002)

    GPIO.output(TRIG, True)
    time.sleep(0.00001)
    GPIO.output(TRIG, False)

    wait_start = time.monotonic()
    pulse_start = wait_start
    while GPIO.input(ECHO) == 0:
        pulse_start = time.monotonic()
        if pulse_start - wait_start > timeout:
            return float("inf")

    pulse_end = pulse_start
    while GPIO.input(ECHO) == 1:
        pulse_end = time.monotonic()
        if pulse_end - pulse_start > timeout:
            return float("inf")

    pulse_duration = pulse_end - pulse_start
    distance = (pulse_duration * SPEED / 2) * 100  # cm
    return distance

try:
    while True:
        dist = measure_distance()
        if dist == float("inf"):
            print("No echo detected")
        else:
            print(f"Distance: {dist:.2f} cm")
        time.sleep(0.2)
except KeyboardInterrupt:
    pass
finally:
    GPIO.cleanup()
```

- 增加超时分支避免超声波失效导致阻塞，并确保总在 `finally` 中归还 GPIO。

### 误差与优化

- 环境温度会影响声速，可按 `C = 331 + 0.6 × T(°C)` 修正。
- 测距时保持传感器平行目标面，避免斜射造成回波弱或丢失。
- 对距离结果应用滑动平均或中值滤波，可减小抖动。

## 实验结果

1. 超声波模块在 5-200cm 范围内测距稳定，典型误差小于 ±1cm。
2. 分压保护后 GPIO 工作正常，无过压告警或异常重启。
3. 脚本实时输出距离，可作为碰撞预警或自动避障基础。
4. 验证了温度校准与滤波策略对提升测距精度的有效性。

# Lab7 蜂鸣器音乐实验

## 实验目的

1.区分有源与无源蜂鸣器的驱动方式，掌握对应的 GPIO 控制策略。
2.使用树莓派输出 PFM/PWM 方波信号，驱动蜂鸣器发出可控音调。
3.编写简易乐曲播放程序，练习频率表映射、节拍控制与占空比调节。
4.评估 3.3V 供电条件下蜂鸣器音量、失真与听感，探索硬件与软件调优空间。

![lab7-实验原理-1](实验报告_media/media/lab7-实验原理-1.png)
![lab7-实验原理-2](实验报告_media/media/lab7-实验原理-2.png)

## 实验过程

### 模块认知与接线

- 有源蜂鸣器内部集成振荡器，低电平触发即可发声，适合播放单一提示音；无源蜂鸣器需外部方波驱动，能输出多种音高。
- 接线建议：`GPIO17` 作为控制脚，`VCC` 接 3.3V，`GND` 接地；若使用硬件 PWM，可选择 `GPIO18` 等支持 PWM 的引脚。
- 注意蜂鸣器模块正负极标识，避免反接；测试时避免长时间高音量连续输出。

![lab7-实验过程-1](实验报告_media/media/lab7-实验过程-1.png)
![lab7-实验过程-2](实验报告_media/media/lab7-实验过程-2.png)

### 驱动原理

- **有源蜂鸣器**：输出高/低电平即可触发或关闭，适合用作报警、提示音。
- **无源蜂鸣器**：需要通过 PWM/PFM 调制频率产生不同音调；采用 50% 占空比可获得稳定响度。
- 使用字典映射音符与频率（如 C=261Hz，A=440Hz），通过延时控制节拍，形成旋律。

### 程序代码

```python
import time
import RPi.GPIO as GPIO

NOTE_FREQ = {
     "C": 261,
     "D": 293,
     "E": 329,
     "F": 349,
     "G": 392,
     "A": 440,
     "B": 493,
}

MELODY = [
     ("C", 0.4),
     ("D", 0.4),
     ("E", 0.4),
     ("C", 0.4),
]

GPIO.setmode(GPIO.BCM)
BUZZ = 18
GPIO.setup(BUZZ, GPIO.OUT)
pwm = GPIO.PWM(BUZZ, 440)
pwm.start(0)

try:
    for note, duration in MELODY:
        freq = NOTE_FREQ[note]
        pwm.ChangeFrequency(freq)
        pwm.ChangeDutyCycle(50)  # 50% duty for clear tone
        time.sleep(duration)
        pwm.ChangeDutyCycle(0)
        time.sleep(0.05)
finally:
    pwm.stop()
    GPIO.cleanup()
```

- 对于有源蜂鸣器，可省略 `ChangeFrequency`，直接输出高/低电平控制。
- 在播放过程中加入短暂静音，避免音符粘连；可通过调整 `MELODY` 列表扩展乐曲。

## 实验结果

1. 有源蜂鸣器在低电平触发下能稳定发声，适合作为系统提示音实现。
2. 无源蜂鸣器配合 PWM 驱动可以正确输出音符，成功播放预设旋律。
3. 3.3V 供电下音量适中，如需更大音量可加驱动晶体管或外接放大器。
4. 频率表与节奏控制逻辑可复用到其他音乐程序，为声音交互实验打下基础。

# Lab8 PS2 操纵杆控制实验

## 实验目的

1.掌握 PS2 模拟摇杆的结构与 X/Y/Z 三通道输出特性。
2.结合 PCF8591 模块完成双路模拟量采样，解析摇杆位移方向与幅度。
3.通过 PWM 控制双色 LED 亮度，实现前后左右四象限的亮度映射。
4.扩展 Z 轴按压事件的处理，探索蜂鸣器、直流电机等多组件联动场景。

![lab8-实验原理-1](实验报告_media/media/lab8-实验原理-1.png)
![lab8-实验原理-2](实验报告_media/media/lab8-实验原理-2.png)

## 实验过程

### 硬件连接

- PCF8591 继续通过 I2C 与树莓派相连：`SDA ↔ SDA`、`SCL ↔ SCL`、`VCC ↔ 5V`、`GND ↔ GND`。
- PS2 摇杆 `VRX`、`VRY` 分别接入 PCF8591 `AIN1`、`AIN0`，数字输出 `SW` 接 `AIN2` 或直接接树莓派 GPIO 读取。
- 双色 LED 红/绿脚连接到支持 PWM 的 GPIO（如 GPIO18、GPIO19），公共端接地；蜂鸣器或其他执行器可根据拓展需求接入。

![lab8-实验过程-1](实验报告_media/media/lab8-实验过程-1.png)

### 信号特性

- 摇杆静止时 X/Y 通道约 2.5V，对应 A/D 数值约 128；向上/右推动值增大，向下/左推动值减小（实际方向需按模块丝印验证）。
- 按下摇杆 Z 轴按钮时 `SW` 输出低电平，未按下时保持高电平。
- 通过映射函数将 0-255 的采样值线性转换为 0-100% 占空比，实现 LED 渐亮/渐暗。

### 程序代码

```python
import smbus
import time
import RPi.GPIO as GPIO

ADDR = 0x48
CTRL_BASE = 0x40  # 允许输出，单端输入

GPIO.setmode(GPIO.BCM)
LED_R = 18
LED_G = 19
GPIO.setup(LED_R, GPIO.OUT)
GPIO.setup(LED_G, GPIO.OUT)
pwm_r = GPIO.PWM(LED_R, 500)
pwm_g = GPIO.PWM(LED_G, 500)
pwm_r.start(0)
pwm_g.start(0)

bus = smbus.SMBus(1)
CENTER = 128
DEAD_ZONE = 10

def read_channels():
    bus.write_byte(ADDR, CTRL_BASE | 0x04 | 0x00)  # 自动增量从 AIN0 开始
    bus.read_byte(ADDR)
    val_y = bus.read_byte(ADDR)
    val_x = bus.read_byte(ADDR)
    val_sw = bus.read_byte(ADDR)
    return val_x, val_y, val_sw

def normalize(value: int) -> float:
    delta = value - CENTER
    if abs(delta) <= DEAD_ZONE:
        return 0.0
    return max(-1.0, min(1.0, delta / (CENTER - DEAD_ZONE)))

def to_duty(level: float) -> float:
    return max(0.0, min(100.0, abs(level) * 100.0))

try:
    while True:
        x_raw, y_raw, sw_raw = read_channels()
        x = normalize(x_raw)
        y = normalize(y_raw)
        pwm_r.ChangeDutyCycle(to_duty(y))
        pwm_g.ChangeDutyCycle(to_duty(x))
        direction = "center"
        if y > 0:
            direction = "forward"
        elif y < 0:
            direction = "backward"
        if x > 0.2:
            direction += " + right"
        elif x < -0.2:
            direction += " + left"
        button = "pressed" if sw_raw < 10 else "released"
        print(f"X={x_raw:3d} Y={y_raw:3d} dir={direction} button={button}")
        time.sleep(0.1)
except KeyboardInterrupt:
    pass
finally:
    pwm_r.stop()
    pwm_g.stop()
    GPIO.cleanup()
```

- 引入死区与方向文本，强调四象限映射；按钮按下时可据此触发声光反馈。

## 实验结果

1. PCF8591 成功采集摇杆 X/Y 模拟量，映射后的 LED 亮度随方向变化线性可感。
2. Z 轴按键触发稳定，结合蜂鸣器实现了即时声效反馈。
3. 通过 PWM 细分占空比后，红绿灯明暗过渡平滑，无明显闪烁。
4. 实验逻辑可扩展到机器人遥控、菜单选择等场景，为复杂人机交互奠定基础。

# Lab9 红外遥控实验

## 实验目的

1.熟悉红外遥控接收头的工作原理与引脚定义，掌握接线安全注意事项。
2.在树莓派上配置 LIRC 环境，实现红外信号的学习、解码与按键识别。
3.通过 Python 程序处理按键事件，控制双色 LED 展示不同状态。
4.探索遥控器多键映射与拓展玩法，为后续声光交互或音乐演奏做准备。

![lab9-实验原理-1](实验报告_media/media/lab9-实验原理-1.png)
![lab9-实验原理-2](实验报告_media/media/lab9-实验原理-2.png)

## 实验过程

### 硬件接线

- 红外接收模块 `VCC` 接 5V，`GND` 接地，信号脚（S 或 OUT）连接 GPIO23（与 `config.txt` 配置保持一致）。
- 若使用红外发射模块，可将发射脚连接 GPIO24。
- 确保模块与树莓派共地，接线完成后再上电，避免热插拔。

![lab9-实验过程-1](实验报告_media/media/lab9-实验过程-1.png)
![lab9-实验过程-2](实验报告_media/media/lab9-实验过程-2.png)

### LIRC 环境配置

1. 安装依赖：
   ```bash
   sudo apt-get update
   sudo apt-get install lirc
   ```
2. 编辑 `/boot/firmware/config.txt`（或 `/boot/config.txt`），新增：
   ```
   dtoverlay=gpio-ir,gpio_pin=23
   dtoverlay=gpio-ir-tx,gpio_pin=24
   ```
3. 修改 `/etc/lirc/lirc_options.conf`：
   ```
   driver = default
   device = /dev/lirc1
   ```
4. 重启树莓派使配置生效：`sudo reboot`。

![lab9-实验过程-3](实验报告_media/media/lab9-实验过程-3.png)
![lab9-实验过程-4](实验报告_media/media/lab9-实验过程-4.png)
![lab9-实验过程-5](实验报告_media/media/lab9-实验过程-5.png)
![lab9-实验过程-6](实验报告_media/media/lab9-实验过程-6.png)

### 按键学习与录制

1. 停止 LIRC 服务并进入原始模式验证：
   ```bash
   sudo service lircd stop
   mode2 -d /dev/lirc1
   ```
   观察是否输出脉冲数据以确认硬件正常。
2. 查看可用按键名：`irrecord -l`。
3. 运行 `irrecord -d /dev/lirc1 ~/myir.lircd.conf`，按提示依次：
   - 输入遥控器文件名（如 `myir`）。
   - 随机按键收集波形数据。
   - 依次录入目标按键（示例录入 `KEY_1~KEY_3`）。
4. 编辑生成文件，删除多余列，仅保留前两列数据，保存并复制到 `/etc/lirc/lircd.conf.d/`。
5. 将原 `devinput.lircd.conf` 重命名为 `devinput.lircd.dist`，重启 LIRC 服务：
   ```bash
   sudo service lircd restart
   sudo irw
   ```
   按键测试确认解码成功。

![lab9-实验过程-7](实验报告_media/media/lab9-实验过程-7.png)
![lab9-实验过程-8](实验报告_media/media/lab9-实验过程-8.png)
![lab9-实验过程-9](实验报告_media/media/lab9-实验过程-9.png)
![lab9-实验过程-10](实验报告_media/media/lab9-实验过程-10.png)

### 程序代码

- 将 `/etc/lirc/lircrc` 中的条目映射到目标程序，例如：
  ```
  begin
      prog = test.py
      button = KEY_1
      config = echo "KEY_1"
  end
  ```
- 示例程序：
```python
import lirc
import RPi.GPIO as GPIO

LED_R = 18
LED_G = 19

GPIO.setmode(GPIO.BCM)
GPIO.setup(LED_R, GPIO.OUT)
GPIO.setup(LED_G, GPIO.OUT)

STATE_MAP = {
     'echo "KEY_1"': (GPIO.HIGH, GPIO.LOW),
     'echo "KEY_2"': (GPIO.LOW, GPIO.HIGH),
     'echo "KEY_3"': (GPIO.LOW, GPIO.LOW),
}

def apply_state(data: str) -> None:
     red, green = STATE_MAP.get(data, (GPIO.LOW, GPIO.LOW))
     GPIO.output(LED_R, red)
     GPIO.output(LED_G, green)
     print(f"Command={data} -> R={'ON' if red else 'OFF'} G={'ON' if green else 'OFF'}")

try:
     with lirc.LircdConnection("test.py") as conn:
          while True:
                payload = conn.readline().strip()
                apply_state(payload)
except KeyboardInterrupt:
     pass
finally:
     GPIO.cleanup()
```
- 调用 GPIO 输出控制双色 LED，实现遥控器按键与灯光状态的直接联动。

![lab9-实验过程-11](实验报告_media/media/lab9-实验过程-11.png)
![lab9-实验过程-12](实验报告_media/media/lab9-实验过程-12.png)

## 实验结果

1. LIRC 成功学习并识别遥控器按键，`irw` 输出稳定匹配录入的键值。
2. Python 程序可根据按键控制双色 LED 呈现红亮、绿亮、全灭三种模式。
3. 配置文件与硬件接线保持一致后，遥控响应延迟低、识别率高。
4. 拓展演示了按键映射音乐的可行性，为后续多模态交互提供基础。

# Lab10 音乐中断实验

## 实验目的

1.理解树莓派 GPIO 外部中断机制，掌握边沿检测与回调函数的使用。
2.设计按键、LED、蜂鸣器协同的中断响应流程，实现音乐播放的暂停与恢复。
3.练习去抖策略与多线程/异步控制，确保中断响应及时且不阻塞主任务。
4.总结中断驱动在多任务场景中的优势与注意事项，为更复杂的事件处理奠定基础。

![lab10-实验原理-1](实验报告_media/media/lab10-实验原理-1.png)

## 实验过程

### 硬件方案

- 复用之前的蜂鸣器与双色 LED，新增按键输入作为中断信号源。
- 建议连接：按键一端接 GPIO17，另一端接 3.3V，并在软件中启用下拉；LED 红/绿脚接 GPIO18/GPIO19，蜂鸣器接 PWM 引脚。
- 注意布线紧凑、避开干扰源，尽量使用共地与合理的去抖电路（如串联小电容或 RC 滤波）。

### 中断编程要点

- 使用 `GPIO.add_event_detect(channel, edge, callback, bouncetime)` 注册中断：
  - `channel`：按键 GPIO 号。
  - `edge`：可设为 `GPIO.FALLING` 或 `GPIO.BOTH`，视按键接法而定。
  - `callback`：中断触发时执行的函数，内部处理状态切换。
  - `bouncetime`：适当设置（如 200ms）以抵消按键抖动。
- 也可使用阻塞式 `GPIO.wait_for_edge(channel, GPIO.RISING)` 在独立线程监听，降低主循环占用。

### 程序代码

```python
import time
import threading
import RPi.GPIO as GPIO

BUTTON = 17
LED = 18
BUZZER = 19

MELODY = [
    (262, 0.4),  # C4
    (294, 0.4),  # D4
    (330, 0.4),  # E4
    (0, 0.2),    # 休止符
    (392, 0.6),  # G4
]

GPIO.setmode(GPIO.BCM)
GPIO.setup(BUTTON, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(LED, GPIO.OUT)
GPIO.setup(BUZZER, GPIO.OUT)

pwm = GPIO.PWM(BUZZER, 440)
pwm.start(0)

state = {"pause_request": False, "stop": False}

def interrupt_handler(channel):
    state["pause_request"] = True

GPIO.add_event_detect(BUTTON, GPIO.RISING, callback=interrupt_handler, bouncetime=200)

def led_flash() -> None:
    for _ in range(4):
        GPIO.output(LED, True)
        time.sleep(0.2)
        GPIO.output(LED, False)
        time.sleep(0.2)

def play_music() -> None:
    while not state["stop"]:
        for freq, duration in MELODY:
            if state["stop"]:
                break
            if freq <= 0:
                pwm.ChangeDutyCycle(0)
                time.sleep(duration)
                continue
            pwm.ChangeFrequency(freq)
            pwm.ChangeDutyCycle(60)
            segment_end = time.monotonic() + duration
            while time.monotonic() < segment_end:
                if state["stop"]:
                    break
                if state["pause_request"]:
                    pwm.ChangeDutyCycle(0)
                    led_flash()
                    state["pause_request"] = False
                    segment_end = time.monotonic() + duration
                    pwm.ChangeFrequency(freq)
                    pwm.ChangeDutyCycle(60)
                time.sleep(0.01)
            pwm.ChangeDutyCycle(0)
        time.sleep(0.3)

player = threading.Thread(target=play_music, daemon=True)
player.start()

try:
     while player.is_alive():
          time.sleep(0.5)
except KeyboardInterrupt:
     state["stop"] = True
     player.join()
finally:
    state["stop"] = True
    if player.is_alive():
        player.join(timeout=1.0)
     pwm.stop()
     GPIO.cleanup()
```

- 音符与节拍循环播放，外部中断触发后暂停当前音符、执行 LED 闪烁，再自动续播。

## 实验结果

1. 按键中断能够即时捕获用户输入，发生时音乐播放暂停并触发 LED 闪烁提示。
2. 中断处理后音乐可从暂停位置继续播放，体验流畅，无明显延迟。
3. `bouncetime` 配置有效抑制按键抖动，系统未出现重复触发或卡死现象。
4. 实验展示了中断驱动在多任务交互中的优势，可扩展到报警响应、状态切换等场景。
